# yaml-language-server: $schema=./values.schema.json
image:
  repository: ghcr.io/twin/gatus
  pullPolicy: IfNotPresent
  tag: v5.35.0@sha256:21609f31be8c4e680ce3004b24276305666239c99aff58391503f3fb6142f39d

sidecarImage:
  repository: ghcr.io/home-operations/gatus-sidecar
  pullPolicy: IfNotPresent
  tag: 0.0.13@sha256:40d549ea5ae89acac94bdf4cee1233e718a96c6e382c67f7e28de688511169d2

sidecar:
  enable: false
  enableService: false
  enableIngress: false
  enableHttproute: false
  autoService: false
  autoIngress: false
  autoHttproute: false
  namespace: ""  # Namespace to watch (empty for all namespaces), only one namespace is supported (string)
  ingressClass: ""  # Ingress class to filter Ingresses, only one ingress class is supported (string)
  gatewayName: ""  # Gateway name to filter HTTPRoutes, only one gateway name is supported (string)

service:
  main:
    ports:
      main:
        port: 8080
        targetPort: 8080

persistence:
  configmain:
    enabled: "{{ .Values.sidecar.enable }}"
    mountPath: /config
    readOnly: false
    targetSelectAll: true
  config:
    enabled: true
    mountPath: /config/config.yaml
    subPath: config.yaml
    readOnly: true
    type: "configmap"
    objectName: config

configmap:
  config:
    enabled: true
    data:
      config.yaml: |
        {{- if .Values.cnpg.main.enabled }}
        storage:
          type: postgres
          path: {{ (printf "%s?client_encoding=utf8" (.Values.cnpg.main.creds.std | trimAll "\"")) | quote }}
        {{- end }}

        endpoints:
          - name: example
            url: https://example.org
            interval: 60s
            conditions:
              - "[STATUS] == 200"
              - "[BODY] == pat(*<h1>Example Domain</h1>*)"

workload:
  main:
    podSpec:
      containers:
        main:
          env:
            GATUS_CONFIG_PATH: "{{ .Values.persistence.configmain.mountPath }}"
            GATUS_DELAY_START_SECONDS: 10
        sidecar:
          enabled: "{{ .Values.sidecar.enable }}"
          imageSelector: sidecarImage
          probes:
            liveness:
              enabled: true
              port: "{{ .Values.service.main.ports.main.port }}"
            readiness:
              enabled: true
              port: "{{ .Values.service.main.ports.main.port }}"
            startup:
              enabled: true
              port: "{{ .Values.service.main.ports.main.port }}"
          args:
            - --output=/config/gatus-sidecar.yaml
            - --enable-service={{ .Values.sidecar.enableService }}
            - --enable-ingress={{ .Values.sidecar.enableIngress }}
            - --enable-httproute={{ .Values.sidecar.enableHttproute }}
            - --auto-service={{ .Values.sidecar.autoService }}
            - --auto-ingress={{ .Values.sidecar.autoIngress }}
            - --auto-httproute={{ .Values.sidecar.autoHttproute }}
            - --namespace={{ .Values.sidecar.namespace }}
            - --ingress-class={{ .Values.sidecar.ingressClass }}
            - --gateway-name={{ .Values.sidecar.gatewayName }}

cnpg:
  main:
    enabled: true
    user: gatus
    database: gatus

# Need sysctl to allow ICMP ping from non-root containers
securityContext:
  pod:
    sysctls:
      - name: net.ipv4.ping_group_range
        value: "0 2147483647"

# Need RBAC to allow sidecar to watch Services and Ingresses
rbac:
  main:
    enabled: "{{ .Values.sidecar.enable }}"
    primary: true
    clusterWide: true
    rules:
      - apiGroups: [""]
        resources:
          - "services"
        verbs:
          - "get"
          - "list"
          - "watch"
      - apiGroups:
          - "networking.k8s.io"
        resources:
          - "ingresses"
          - "ingressclasses"
        verbs:
          - "get"
          - "list"
          - "watch"
      - apiGroups:
          - "gateway.networking.k8s.io"
        resources:
          - "httproutes"
          - "gateways"
        verbs:
          - "get"
          - "list"
          - "watch"

# Need ServiceAccount for RBAC
serviceAccount:
  main:
    enabled: true
    primary: true

# Need automountServiceAccountToken to allow sidecar to use the ServiceAccount
podOptions:
  automountServiceAccountToken: true
